package org.snomed.snowstorm.core.data.services.identifier;

import co.elastic.clients.elasticsearch._types.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.snomed.snowstorm.core.data.domain.*;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.elasticsearch.core.ElasticsearchOperations;
import org.springframework.data.elasticsearch.core.SearchHit;
import org.springframework.data.elasticsearch.core.SearchHits;
import org.springframework.data.elasticsearch.client.elc.NativeQueryBuilder;

import java.util.*;

import static io.kaicode.elasticvc.helper.QueryHelper.*;

/**
 * Generates SNOMED Component identifiers locally using sequential identifiers.
 * The store is queried to find the largest sequence number.
 * Assumes that SCTIDs in the same sequence are not being generated by other services/applications, otherwise identifier collision is likely.
 */
public class LocalSequentialIdentifierSource implements IdentifierSource {

	private final ElasticsearchOperations elasticsearchOperations;
	private final Map<String, Integer> namespaceAndPartitionHighestSequenceCache = Collections.synchronizedMap(new HashMap<>());
	private final Logger logger = LoggerFactory.getLogger(getClass());

	public LocalSequentialIdentifierSource(ElasticsearchOperations elasticsearchOperations) {
		this.elasticsearchOperations = elasticsearchOperations;
	}

	@Override
	public List<Long> reserveIds(int namespaceId, String partitionId, int quantity) {
		List<Long> newIdentifiers = new ArrayList<>();
		int sequence = findHighestIdentifierSequence(namespaceId, partitionId);

		synchronized (namespaceAndPartitionHighestSequenceCache) {
			// Take sequence from cache if it's higher. This is possible if ids have been reserved but not yet persisted in records
			String sequenceCacheKey = namespaceId + "_" + partitionId;
			int sequenceCacheValue = namespaceAndPartitionHighestSequenceCache.getOrDefault(sequenceCacheKey, 0);
			if (sequenceCacheValue > sequence) {
				sequence = sequenceCacheValue;
			}

			for (int i = 0; i < quantity; i++) {
				sequence++;

				String namespace = namespaceId == 0 ? "" : namespaceId + "";
				String sctidWithoutCheck = sequence + namespace + partitionId;
				char verhoeff = VerhoeffCheck.calculateChecksum(sctidWithoutCheck, 0, false);
				long newSctid = Long.parseLong(sctidWithoutCheck + verhoeff);
				newIdentifiers.add(newSctid);
			}

			namespaceAndPartitionHighestSequenceCache.put(sequenceCacheKey, sequence);
		}

		return newIdentifiers;
	}

	/**
	 * Finds highest SCTID in the given namespace and partition across all branches and versions. Returns the sequence identifier.
	 * @return Sequence from the highest existing SCTID.
	 */
	private int findHighestIdentifierSequence(int namespaceId, String partitionId) {

		Class<? extends SnomedComponent<?>> componentClass = null;
		String idField = switch (partitionId) {
			case "00", "10" -> {
				// Concept identifier
				componentClass = Concept.class;
				yield Concept.Fields.CONCEPT_ID;
			}
			case "01", "11" -> {
				// Description identifier
				componentClass = Description.class;
				yield Description.Fields.DESCRIPTION_ID;
			}
			case "02", "12" -> {
				// Relationship identifier
				componentClass = Relationship.class;
				yield Relationship.Fields.RELATIONSHIP_ID;
			}
			case "16" -> {
				// Expression identifier
				componentClass = ReferenceSetMember.class;
				yield ReferenceSetMember.Fields.REFERENCED_COMPONENT_ID;
			}
			default -> null;
		};

		if (idField == null) {
			throw new IllegalArgumentException(String.format("Partition '%s' is not handled by the configured identifier generator.", partitionId));
		}

		String regex;
		if (namespaceId == 0) {
			// International
			// Restricting sequence length avoids matching extensions and long International model ids like "900000000000550004"
			regex = String.format("[0-9]{0,11}%s[0-9]", partitionId);
		} else {
			// Extension
			regex = String.format("[0-9]*%s%s[0-9]", namespaceId, partitionId);
		}

		SearchHits<? extends SnomedComponent<?>> searchHits = elasticsearchOperations.search(new NativeQueryBuilder()

				// Regex query
				.withQuery(regexpQuery(idField, regex))

				// Numbers as strings require sorting by length and characters:
				// Sort by string length first.
				.withSort(scriptSortByIdLengthInDesc(idField))
				// then sort by characters.
				.withSort(SortOptions.of(s -> s.field(f -> f.field(idField).order(SortOrder.Desc))))

				// One item
				.withPageable(PageRequest.of(0, 1))

				.build(), componentClass);

		int highestSequence = 0;
		if (searchHits.hasSearchHits()) {
			SearchHit<? extends SnomedComponent<?>> searchHit = searchHits.getSearchHit(0);
			SnomedComponent<?> component = searchHit.getContent();
			String highestSctid;
			if (idField.equals(ReferenceSetMember.Fields.REFERENCED_COMPONENT_ID)) {
				highestSctid = ((ReferenceSetMember) component).getReferencedComponentId();
			} else {
				highestSctid = component.getId();
			}
			String itemIdentifier;
			if (namespaceId == 0) {
				itemIdentifier = highestSctid.substring(0, highestSctid.length() - 3);
			} else {
				itemIdentifier = highestSctid.substring(0, highestSctid.lastIndexOf(namespaceId + ""));
			}
			if (itemIdentifier.length() <= 8) {
				highestSequence = Integer.parseInt(itemIdentifier);
			} else {
				logger.error("{} found with bad SCTID '{}' on branch {}, this will prevent identifier generation.",
						componentClass.getSimpleName(), highestSctid, component.getPath());
			}
		}

		if (namespaceId == 0 && highestSequence < 100) {
			highestSequence = 100;
		}

		return highestSequence;
	}

	@Override
	public void registerIds(int namespace, Collection<Long> idsAssigned) {
		// Not required for this implementation.
	}

	private SortOptions scriptSortByIdLengthInDesc(String idField) {
		return SortOptions.of(s -> s.script(ScriptSort.of(b -> b.type(ScriptSortType.Number)
				.script(sb -> sb.inline(InlineScript.of(is -> is.source(String.format("doc['%s'].value.length()", idField)))))
				.order(SortOrder.Desc))));
	}
}
